// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const getRating = `-- name: GetRating :one
SELECT id, workkey, editionkey, ratingvalue, datestamp FROM rating
WHERE id = ? LIMIT 1
`

func (q *Queries) GetRating(ctx context.Context, id int64) (Rating, error) {
	row := q.db.QueryRowContext(ctx, getRating, id)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.Workkey,
		&i.Editionkey,
		&i.Ratingvalue,
		&i.Datestamp,
	)
	return i, err
}

const getRereading = `-- name: GetRereading :one
SELECT id, workkey, editionkey, shelf, datestamp FROM reading
WHERE id = ? LIMIT 1
`

func (q *Queries) GetRereading(ctx context.Context, id int64) (Reading, error) {
	row := q.db.QueryRowContext(ctx, getRereading, id)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.Workkey,
		&i.Editionkey,
		&i.Shelf,
		&i.Datestamp,
	)
	return i, err
}

const insertRating = `-- name: InsertRating :exec
INSERT INTO rating (workkey, editionkey, ratingvalue, datestamp) VALUES (?, ?, ?, ?)
`

type InsertRatingParams struct {
	Workkey     string
	Editionkey  sql.NullString
	Ratingvalue sql.NullFloat64
	Datestamp   sql.NullString
}

func (q *Queries) InsertRating(ctx context.Context, arg InsertRatingParams) error {
	_, err := q.db.ExecContext(ctx, insertRating,
		arg.Workkey,
		arg.Editionkey,
		arg.Ratingvalue,
		arg.Datestamp,
	)
	return err
}

const insertReading = `-- name: InsertReading :exec
INSERT INTO reading (workkey, editionkey, shelf, datestamp) VALUES (?, ?, ?, ?)
`

type InsertReadingParams struct {
	Workkey    string
	Editionkey sql.NullString
	Shelf      sql.NullString
	Datestamp  sql.NullString
}

func (q *Queries) InsertReading(ctx context.Context, arg InsertReadingParams) error {
	_, err := q.db.ExecContext(ctx, insertReading,
		arg.Workkey,
		arg.Editionkey,
		arg.Shelf,
		arg.Datestamp,
	)
	return err
}

const listRatings = `-- name: ListRatings :many
SELECT id, workkey, editionkey, ratingvalue, datestamp FROM rating
`

func (q *Queries) ListRatings(ctx context.Context) ([]Rating, error) {
	rows, err := q.db.QueryContext(ctx, listRatings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rating
	for rows.Next() {
		var i Rating
		if err := rows.Scan(
			&i.ID,
			&i.Workkey,
			&i.Editionkey,
			&i.Ratingvalue,
			&i.Datestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReadings = `-- name: ListReadings :many
SELECT id, workkey, editionkey, shelf, datestamp FROM reading
`

func (q *Queries) ListReadings(ctx context.Context) ([]Reading, error) {
	rows, err := q.db.QueryContext(ctx, listReadings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reading
	for rows.Next() {
		var i Reading
		if err := rows.Scan(
			&i.ID,
			&i.Workkey,
			&i.Editionkey,
			&i.Shelf,
			&i.Datestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
